<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cheese High</title>
  <subtitle>Cheese High</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cheesehigh.com/"/>
  <updated>2016-12-31T08:50:41.000Z</updated>
  <id>http://cheesehigh.com/</id>
  
  <author>
    <name>CheeseHigh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极简版希腊神话</title>
    <link href="http://cheesehigh.com/2016/12/31/greekmyth/"/>
    <id>http://cheesehigh.com/2016/12/31/greekmyth/</id>
    <published>2016-12-31T07:59:59.000Z</published>
    <updated>2016-12-31T08:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>大四在新东方学习GRE时，老师总会在课堂上通过希腊神话讲词根词源，我听了十分感兴趣，可以说希腊文明是西方文明的发源地，后来就找来了BBC拍的纪录片”诸神之战” (Clash of the Gods)。这部纪录片一共有10集，每集讲述一个希腊神话和北欧神话中的标志性人物，并联系史实试图解释这些神话产生的原因。希腊神话一个比较鲜明的特点是神的数量众多，且情感和行动和人非常相似。</p>
<p>全剧贯穿了两个中心思想：</p>
<p><strong>1. 神也不能违背命运。</strong><br><strong>2. 神话是现实的反映。</strong></p>
<h4 id="故事是这样的"><a href="#故事是这样的" class="headerlink" title="故事是这样的"></a>故事是这样的</h4><p>大地女神盖亚(Gaia)无性繁殖了天空之神乌拉诺斯(Uranus, 第一代天神)，母子乱伦生了十二个泰坦巨人(包括克洛诺斯，瑞亚和普罗米修斯)，三个独眼巨人和三个百臂巨人。</p>
<p>泰坦巨人克洛诺斯(Kronos, 第二代天神)和瑞亚(Rhea)生了奥林匹亚诸神(包括宙斯Zeus，海神波塞冬Poseidon，地狱冥神哈迪斯Hades，德墨忒尔Demeter，赫拉Hera)，克洛诺斯为了不被儿女夺权而吞了他们，但是宙斯被偷偷藏在克里特岛，长大以后和奥林匹亚诸兄弟姐妹，独眼巨人，百臂巨人弑父夺权。他与波塞冬和哈迪斯抽签分工，最终宙斯成为第三代天神，波塞冬成为海神，哈迪斯成为地狱冥神。</p>
<p>宙斯是个淫棍，虽和赫拉结婚但还是四处留情，生了许多孩子，包括阿波罗(Appollo)，赫拉克勒斯(Hercules)，后来遇到政变，罚阿波罗和波塞冬造特洛伊城墙。</p>
<p>普罗米修斯(Prometheus)与雅典娜(Athena)创造人类，普罗米修斯为人类偷火，被宙斯锁在高加索山上，并把潘多拉送给人类作为惩罚(雅典娜没给她智慧)，之后宙斯送给潘多拉一个盒子(Pandora’s box)。</p>
<p>赫拉克勒斯是宙斯和别人的孩子，因此与赫拉敌对，受其影响杀了妻子，并完成12个任务而救赎，打开了直布罗陀海峡，烧死升天成为神。</p>
<p>阿特拉斯(Atlas)在世界尽头背着世界。</p>
<p>冥神哈迪斯掌管地狱(塔尔塔洛斯, Tartarus)，绑架了丰收之神德墨忒尔的女儿泊尔塞福涅(Persephone)，有时归还，从此有了四季。地狱里有三头狗(Cerberus)，百臂巨人(hundred-handers)，死神(Charon)，要在死者嘴里放硬币当渡河费。西西弗斯欺骗死亡，被罚推石头。俄耳甫斯想用音乐救妻子返回人间，但规定走回人间的行程中不准回头，可惜他忍不住回头了。</p>
<p>弥诺陶洛斯(Minotaur)，波塞冬惩罚克里特国王，让王后和公牛交配所生。关在迷宫中，吃雅典的人祭，被忒休斯(Theseus)所杀，但他回程时忘记与父王的约定，没有升起白帆以示胜利，父王以为忒休斯死亡便跳进爱琴海。</p>
<p>美杜莎(Medusa)，看见就石化，原是雅典娜的祭司，被波塞冬强奸，反而被雅典娜惩罚变成怪物。玻耳修斯(Perseus, 宙斯的儿子)的母亲被强行结婚，玻耳修斯杀了美杜莎来救母亲。</p>
<p>伊利亚特(Iliad)讲阿喀琉斯十年特洛伊战争，奥德赛(Odyssey)讲奥德修斯返乡的故事。</p>
<p>斯堪的纳维亚半岛的贝奥武甫(Beowulf)到丹麦杀了格伦德尔(Grendel)和他母亲，回基特兰杀退瑞典人，杀火龙。</p>
<p>北欧神话战神奥丁(Odin)，儿子雷神托尔(Thor)，兄弟洛基(Loki, 在漫威宇宙中成了托尔的兄弟)。神话反映了和基督教的斗争。诸神的黄昏是北欧神话中的一连串巨大劫难，包括造成许多重要神祇死亡的大战（奥丁、索尔、弗雷、海姆达尔、火巨人、霜巨人、洛基等），无数的自然浩劫，之后整个世界沉没在水底。然而最终世界复苏了，存活的神与两名人类重新建立了新世界。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大四在新东方学习GRE时，老师总会在课堂上通过希腊神话讲词根词源，我听了十分感兴趣，可以说希腊文明是西方文明的发源地，后来就找来了BBC拍的纪录片”诸神之战” (Clash of the Gods)。这部纪录片一共有10集，每集讲述一个希腊神话和北欧神话中的标志性人物，并联
    
    </summary>
    
      <category term="History" scheme="http://cheesehigh.com/categories/History/"/>
    
    
  </entry>
  
  <entry>
    <title>《鸟哥的Linux私房菜》 Reading Notes</title>
    <link href="http://cheesehigh.com/2016/12/31/linux/"/>
    <id>http://cheesehigh.com/2016/12/31/linux/</id>
    <published>2016-12-31T04:30:39.000Z</published>
    <updated>2016-12-31T05:05:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于本科专业的课程设置非常不合理(存在着地理信息系统、RFID传感器等看似很重要但老师自己也不懂上得无比水和烂的课，我认为即使是物联网工程专业也应当重视计算机的基础课)，无奈只能自己买书来自学，技术的同学不熟悉Linux简直是寸步难行。这里分享一下《鸟哥的Linux私房菜》的读书笔记，内容主要以重要知识点的形式呈现。</p>
<ul>
<li><p>计算机五大单元</p>
<ul>
<li>输入单元</li>
<li>输出单元</li>
<li>CPU控制单元</li>
<li>CPU运算逻辑单元</li>
<li>内存</li>
</ul>
</li>
<li><p>服务器的设计目的是稳定不死机</p>
</li>
<li><p>硬盘和速度用十进制</p>
</li>
<li><p>主板</p>
<ul>
<li>连接各个组件，有芯片组，电池，BIOS</li>
<li>Intel：北桥连接CPU、内存、显卡，南桥连接硬盘、USB、网卡</li>
<li>北桥总线为系统总线，南桥总线为输入输出总线</li>
<li>AMD：将内存集成进CPU</li>
</ul>
</li>
<li><p>CPU</p>
<ul>
<li>不同CPU有不同的指令集，代表着不同技能</li>
<li>两种CPU<ul>
<li>精简指令集RISC：IBM的ARM系列，用于手机</li>
<li>复杂指令集CISC：Intel、AMD的x86系列，用于PC</li>
</ul>
</li>
<li>主频=外频*倍频</li>
<li>CPU位数为每次能够处理的数据量（字组大小）</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li>使用DRAM</li>
<li>双通道设计将两个内存集合在一起</li>
<li>SRAM为CPU中的缓存（cache）</li>
</ul>
</li>
<li><p>显卡（VGA，Video Graphics Array）</p>
<ul>
<li>颜色占用显存</li>
<li>内嵌GPU进行3D加速</li>
</ul>
</li>
<li><p>操作系统</p>
<ul>
<li>内核：驱动硬件，资源分配，进程管理，内存管理，文件管理</li>
<li>系统调用：调用内核</li>
<li>应用程序在操作系统提供的接口上开发</li>
</ul>
</li>
<li><p>历史</p>
<ul>
<li>Multics</li>
<li>Unics</li>
<li>Unix(Ken Thompson, Dennis Ritchie from AT&amp;T’s Bell Lab)</li>
<li>System V &amp; BSD(Berkeley Software Distribution)</li>
<li>Posix Standards</li>
<li>Unix收回版权</li>
<li>Minix</li>
<li>Linux</li>
<li>Mac OS X 基于 Free BSD</li>
<li>Android 基于 Linux</li>
</ul>
</li>
<li><p>每一个设备为文件</p>
</li>
<li>磁盘每个扇区（非扇形）大小为512B，扇区组成的圆形为磁道，所有盘片的磁道组成柱面，以柱面号来分区</li>
<li>第一个扇区包含：主引导分区MBR（Master Boot Record）和分区表</li>
<li>分区表：主分区+扩展分区（包含逻辑分区），最多4个</li>
<li>开机先启动BIOS，再找到MBR启动引导加载程序（boot loader），启动操作系统</li>
<li>其他分区有引导扇区（boot sector），启动引导加载程序（多重引导）</li>
<li>挂载：目录树和文件系统的关联</li>
<li><p>swap：内存不够，将不常使用的放到硬盘中</p>
</li>
<li><p>文件权限</p>
<ul>
<li>chgrp</li>
<li>chown</li>
<li>chmod</li>
<li>user, group, others, all</li>
<li>rwx</li>
</ul>
</li>
<li><p>目录配置</p>
<ul>
<li>Filesystem Hierarchy Standard：是否可分享，是否可变</li>
<li>/：根目录，系统文件</li>
<li>/usr：UNIX Software Resource，软件</li>
<li>/var：系统运行，数据库</li>
</ul>
</li>
<li><p>which：查找PATH中的执行文件</p>
</li>
<li>whereis,locate：查找数据库中的文件，快</li>
<li>find：查找硬盘中的文件，慢</li>
<li><p>find . -name ‘file’</p>
</li>
<li><p>文件系统</p>
<ul>
<li>Ext2</li>
<li>boot sector</li>
<li>block group</li>
<li>super block：文件系统整体信息</li>
<li>inode：文件（文件属性与文件block号，每个文件对应一个inode），目录（目录属性与目录block号）</li>
<li>block：文件（内容），目录（文件名和文件inode号）</li>
<li>df：查询磁盘使用量</li>
<li>du：查询目录的磁盘使用量</li>
<li>分区（fdisk）-&gt;格式化，创建文件系统（mkfs）-&gt;挂载目录（mount）</li>
<li>硬连接（ln）：不同目录block指向同一个文件的inode</li>
<li>符号连接（ln -s）：指向目录的inode</li>
</ul>
</li>
<li><p>压缩和打包</p>
<ul>
<li>gzip: file.gz</li>
<li>bzip2: file.bz2</li>
<li>打包压缩: tar -zcvf file.tar.gz(tgz)</li>
<li>解压缩包: tar -zxvf file.tar.gz</li>
<li>dump: 备份文件系统或目录</li>
<li>restore: 还原备份</li>
</ul>
</li>
<li><p>vim</p>
<ul>
<li>vim是vi的高级版，带有颜色便于编辑程序</li>
<li>一般模式-&gt;ioa(插入)r(替换)-&gt;编辑模式</li>
<li>一般模式-&gt;:,/,?-&gt;命令行模式</li>
<li>ctrl+f：向下翻页</li>
<li>ctrl+b：向上翻页</li>
<li>0：本行开头</li>
<li>$：本行末尾</li>
<li>G：最后一行</li>
<li>nG：第n行</li>
<li>gg：第一行</li>
<li>dd：删除整行</li>
<li>nyy：复制n行</li>
<li>p：粘贴</li>
<li>u：撤销</li>
<li>ctrl+r：重做</li>
<li>ctrl+v：块选择</li>
<li>/word：向下寻找word，用n向下查找</li>
<li>?word：向上寻找word，用N向上查找</li>
<li>:1,$s/word1/word2/g：从开头到末尾用word2替换word1</li>
<li>:set nu：显示行号</li>
<li>:sp file：多窗口</li>
<li>ctrl+w+上/下：多窗口切换</li>
</ul>
</li>
<li><p>shell</p>
<ul>
<li>操作系统内核给用户的接口</li>
<li>bash：Linux的一种标准shell</li>
<li>type：判断是否是bash内置命令</li>
<li>pwd：当前目录</li>
<li>env：查看环境变量</li>
<li>cd：直接回到用户主文件夹</li>
<li>alias ll=’ls -al –color=auto’</li>
<li>自定义变量不能在子进程中使用，环境变量能在子进程中使用</li>
<li>export VAR：使自定义变量VAR成为环境变量</li>
<li>/etc/profile：全局环境配置文件</li>
<li>~/.bashrc：用户环境配置文件</li>
<li>变量=$(命令)</li>
<li>变量=$((算式))</li>
<li>ctrl+d：结束输入(EOF)</li>
<li>ctrl+c：中止命令</li>
<li>ctrl+u：删除命令</li>
<li>ctrl+a：移到开头</li>
<li>ctrl+e：移到末尾</li>
<li>数据流重定向<ul>
<li>stdin：0，&lt;(由文件代替键盘输入)，&lt;&lt;(结束输入符)</li>
<li>stdout：1，&gt;(覆盖)，&gt;&gt;(累加)</li>
<li>stderr：2，&gt;(覆盖)，&gt;&gt;(累加)</li>
</ul>
</li>
<li>; 连续命令</li>
<li>$? 回转码，上个命令执行成功则为0</li>
<li>cmd1 &amp;&amp; cmd2：cmd1成功则执行cmd2</li>
<li>cmd1 || cmd2：cmd1失败则执行cmd2</li>
<li>管道命令(仅处理stdout)</li>
<li>cat file | grep ‘word’</li>
<li>grep ‘word’ file：取出整行</li>
<li>cut：行内分割</li>
<li>sed：行增删改</li>
<li>awk：行内字段处理</li>
</ul>
</li>
<li><p>通配符</p>
<ul>
<li>? 任意一个字符</li>
<li>* 0到无穷个字符</li>
<li>[] 字符集合</li>
<li>[-] 连续字符</li>
<li>[^] 反向选择</li>
</ul>
</li>
<li><p>正则表达式(Regular Expression, RE, RegEx)</p>
<ul>
<li>处理字符串的一种标准依据</li>
<li>元字符</li>
<li>[:alnum:] 字母+数字</li>
<li>[:alpha:] 字母</li>
<li>[:upper:] 大写字母</li>
<li>[:lower:] 小写字母</li>
<li>[:digit:] 数字</li>
<li>[] 字符集合表示一个字符</li>
<li>() 字符分组表示一组字符</li>
<li>[^] 反选</li>
<li>^ 行首</li>
<li>$ 行尾</li>
<li>. 任意一个字符</li>
<li>\w 任意一个字母，数字，下划线，汉字</li>
<li>\s 空格</li>
<li>\d 数字</li>
<li>\b 单词开始或结束</li>
<li>大写为反选</li>
<li>c* 0到无穷多个的c</li>
<li>c+ 1到无穷多个的c</li>
<li>c? 0个或1个c</li>
<li>c{5} 5个c</li>
<li>c{2,5} 2到5个c</li>
<li>| 或</li>
</ul>
</li>
</ul>
<ul>
<li>shell script<ul>
<li>#!/bin/bash 声明使用的shell名称</li>
<li>#注释</li>
<li>sh -n：检查语法</li>
<li>sh -x：调试执行过程</li>
<li>test 测试命令</li>
<li>-e 是否存在</li>
<li>-f 是否存在且为文件</li>
<li>-d 是否存在且为目录</li>
<li>$0 文件名</li>
<li>$1, $2… 命令参数 </li>
<li>条件判断</li>
<li>函数(放在脚本最前面)</li>
<li>循环</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if [ condition ]; then</div><div class="line">elif [ condition ]; then</div><div class="line">else</div><div class="line">fi</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">case $1 in</div><div class="line">     &quot;&quot; )</div><div class="line">          ;;</div><div class="line">     * )</div><div class="line">          ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function fname () &#123;</div><div class="line">     直接使用形参$1, $2...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">while/until [ condition ]</div><div class="line">do</div><div class="line">done</div><div class="line">for var in ...</div><div class="line">do</div><div class="line">done</div></pre></td></tr></table></figure>
<ul>
<li>用户账号UID /etc/passwd</li>
<li>用户组GID /etc/group</li>
<li>密码 /etc/shadow</li>
<li>访问控制列表(Access Control List)：对单个用户或用户组进行权限管理</li>
<li>sudo：让/etc/sudoers中的用户仅通过自己的密码进行其他用户的操作</li>
<li>磁盘Quota：公平分配磁盘给用户，soft-&gt;gracetime-&gt;hard</li>
<li>Redundant Arrays of Inexpensive Disks：根据性能和备份有不同等级</li>
<li>Logical Volume Manager逻辑卷管理器：弹性调整文件系统容量</li>
<li><p>日志文件：/var/log</p>
</li>
<li><p>例行性工作</p>
<ul>
<li>at：一次</li>
<li>crontab：循环</li>
<li>crontab -e</li>
<li>分 时 日 月 周 命令</li>
<li>日月和周不可并存</li>
</ul>
</li>
<li><p>进程管理</p>
<ul>
<li>硬盘程序加载到内存中为进程PID</li>
<li>父进程PPID-&gt;fork-&gt;exec-&gt;子进程</li>
<li>daemon(守护进程，系统服务)：常驻内存的进程</li>
<li>standalone+super daemon</li>
</ul>
</li>
<li><p>单一终端机的工作管理</p>
<ul>
<li>command &amp;：放到后台运行</li>
<li>ctrl+z：放到后台暂停</li>
<li>jobs：查看后台工作</li>
<li>fg：后台工作拿到前台运行</li>
<li>bg：让后台工作继续运行</li>
<li>kill -1 PID：重启</li>
<li>kill -9 PID：强制中止</li>
<li>kill -15 PID：正常结束</li>
<li>ps -l：自己的进程</li>
<li>ps aux：所有系统进程</li>
<li>top：动态查看进程变化，P以CPU排序，M以内存排序</li>
<li>进程优先级PRI = PRI +nice</li>
<li>netstat：网络状态</li>
<li>ifconfig：查询IP</li>
<li>whois：域名所有者信息</li>
<li>host：DNS服务器</li>
<li>nslookup：域名解析</li>
<li>SELinux(Security Enhanced Linux)：避免主体进程误用目标资源</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于本科专业的课程设置非常不合理(存在着地理信息系统、RFID传感器等看似很重要但老师自己也不懂上得无比水和烂的课，我认为即使是物联网工程专业也应当重视计算机的基础课)，无奈只能自己买书来自学，技术的同学不熟悉Linux简直是寸步难行。这里分享一下《鸟哥的Linux私房菜》
    
    </summary>
    
      <category term="Tech" scheme="http://cheesehigh.com/categories/Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP Reading Notes</title>
    <link href="http://cheesehigh.com/2016/12/31/csapp/"/>
    <id>http://cheesehigh.com/2016/12/31/csapp/</id>
    <published>2016-12-30T16:04:44.000Z</published>
    <updated>2016-12-31T03:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一下我在上CMU的18-600: Foundations of Computer Systems (15-213: Introduction to Computer Systems在ECE系的改编课程)时对教材”Computer Systems: A Programmer’s Perspective” (CSAPP)的读书笔记，内容按照原书章节组织，主要以重要知识点的形式呈现。</p>
<h3 id="A-Tour-of-Computer-Systems"><a href="#A-Tour-of-Computer-Systems" class="headerlink" title="A Tour of Computer Systems"></a>A Tour of Computer Systems</h3><ul>
<li>Information = bits + context</li>
<li>Compilation system<ul>
<li>Pre-processor: add head file to source file, program.i</li>
<li>Compilation: translate source file into assembly language, program.s</li>
<li>Assembly: translate assembly language into relocatable object file, program.o</li>
<li>Linking: link all relocatable object program to executable object file, program</li>
</ul>
</li>
<li>GNU provides environment tools for Linux</li>
<li>Virtual Memory(virtual address space): program-runtime heap-shared libraries-stack-kernel</li>
<li>multiprocessor: multi-cores + hyperthread</li>
</ul>
<h3 id="Representing-and-Manipulating-Information"><a href="#Representing-and-Manipulating-Information" class="headerlink" title="Representing and Manipulating Information"></a>Representing and Manipulating Information</h3><ul>
<li>little endian: less significant bytes in low address; big endian: more significant bytes in low address</li>
<li>typedef unsigned char *byte_pointer: type alias</li>
<li>Bit Operation: ~ NOT; ^ Exclusive OR</li>
<li>Logic Operation(&amp;&amp;, ||, !): Any non-zero parameter = 1</li>
<li>Sign bit =-2^w-1</li>
<li>Signed &lt;-&gt; Unsigned: Bit pattern do not change, +/- 2^w</li>
<li>Signed mixed with unsigned: signed -&gt; unsigned</li>
<li>Pay attention to Tmin and 0</li>
<li>Java only supports signed integer</li>
<li>Two’s Complement = Signed = 补码; Addition = Bit addition + truncating</li>
<li>Multiplication is costly, use shift + addition/substraction</li>
<li>Unsigned Division: right logic shift; Two’s Complement Division: right arithmetic shift</li>
<li>IEEE floating point = (-1)^s <em> M(frac) </em> 2^E(exp), need approximation and round</li>
<li>Normalized: exp != all 0 &amp;&amp; exp !=all 1: E = exp - bias(2^k-1 - 1); M = 1 + .frac;</li>
<li>Denormalized: exp == all 0: E = 1- bias; M = .frac;</li>
<li>Special value: exp == all 1: Inf(frac = all 0, should be set to 0); NaN(frac != 0)</li>
<li>In the half, round to even</li>
<li>unsigned int a = 15213U;</li>
<li>long: 4 Bytes(32 bit); 8 Bytes(64 bit)</li>
<li>size_t: unsigned int(32 bit); long unsigned int(64 bit)</li>
</ul>
<h3 id="Machine-Level-Representation-of-Programs"><a href="#Machine-Level-Representation-of-Programs" class="headerlink" title="Machine-Level Representation of Programs"></a>Machine-Level Representation of Programs</h3><ul>
<li>gcc -O1(optimization level) -g(source code line) -o(compile stage) p p1.c p2.c</li>
<li>objdump -d program.o: disassembler generate assembly code from object code</li>
<li>Assembly Language: AT&amp;T Format(-&gt;) V.S. Intel Format(&lt;-)</li>
<li>byte(b): 8 bits; word(w): 16 bits; long word(l): 32 bits; quad word(q): 64 bits</li>
<li>Register: %rax(64)-%eax(32)-%ax(16)-%ah(15-8)-%al(7-0)</li>
<li>ax, cx, dx(caller-save); bx, si, di(callee-save): generally purpose; sp: stack pointer; bp: frame pointer</li>
<li>$immediate, %Register, disp(base, index*scale)</li>
<li>SUB src, dst: dst - src -&gt; dst</li>
<li>64-bit Multiply: imull src: src * %eax -&gt; %edx:%eax</li>
<li>64-bit Divide: idivl src: %edx:%eax / src -&gt; %eax, %edx:%eax mod src -&gt; %edx</li>
<li>cltd: %eax -&gt; %edx:%eax</li>
<li>SAL(Arithmetic Left); SHL(Logical Left); SAR(Arithmetic Right); SHR(Logical Right)</li>
<li>condition codes: ZF(zero); SF(negative); OF(signed overflow); CF(unsigned overflow)</li>
<li>cmp s2,s1: s1-s2(set condition codes then); set dst; jmp label/*address; signed(g/l); unsigned(a/b)</li>
<li>if-else: jmp label; loop: label; jmp label; switch: jump table contains address</li>
<li>conditional expression: cmov, conditional move, compute all first, better performance than conditional control for pipeline misprediction</li>
<li>procedure(stack frame): (caller)local var, params, return addr, (callee)bp(higher), local var, sp(lower)</li>
<li>Array: contiguous memory, address +/- with data type</li>
<li>Union: Store one field at a time, referenced by data type</li>
<li>Alignment: data address must be multiple of its size</li>
<li>x86-64: IA64-AMD64-Intel64: six parameters by ordered register(di,si,dx,cx,r8,r9), no %bp</li>
<li>Buffer overflow attack: strcpy to inject instructions and change return address</li>
<li>struct member address must align</li>
</ul>
<h3 id="Processor-Architecture"><a href="#Processor-Architecture" class="headerlink" title="Processor Architecture"></a>Processor Architecture</h3><ul>
<li>Y86: Balance between CISC and RISC</li>
<li>F: No register</li>
<li>HCL(Hardware Control Language): Describe control logic circuit</li>
<li>bool out = f(logic operator);</li>
<li>multiplexor(output one of the inputs): int out = [s in {I}:A; 1:B];</li>
<li>clocked registers: state = output, update when clock rise</li>
<li>random-access memories: given address, register file</li>
<li>SEQ(Sequential) Processor: Serve one instruction until it finishes</li>
<li>Instruction stage: fetch-decode-execute-memory-write back(register)-PC update</li>
<li>Every instruction uses one clock cycle. As clock rises, state elements(PC, CC, register file, RAM) updated according to the previous instruction. In the clock cycle, combinational logic propagate to create new value for state elements updated in next clock rise</li>
<li>Slow: Each hardware unit is only active for a fraction of the clock cycle</li>
<li>Pipelined Processor: One instruction finished this stage will move on to next, next instruction will come</li>
<li>throughput = 1 / clock period(stage + pipeline register)</li>
<li>The former instruction move on, the address of next instruction(new PC) must be predicted</li>
<li>instruction dependency hazard(data + control): stalling + forwarding + both(load interlock)</li>
<li>SEQ+: move PC update to the beginning</li>
<li>PIPE-: insert pipeline regisger(before the corresponding stage)</li>
<li>PIPE: forward logic in decode stage</li>
<li>Exception Handling: stat field in pipeline register</li>
<li>CPI = 1 + Cbubble/Cinstuction = 1 + load/use + mispredict + ret</li>
<li>Branch Target Buffer for dynamic branch prediction: previous instruction addr -&gt; target addr</li>
<li>Register Rename: small architecture regs -&gt; large physical regs, ARF -&gt; RRF</li>
<li>Load Bypassing: load ahead of store; Load Forwarding: forward store to load</li>
</ul>
<h3 id="Optimizing-Program-Performance"><a href="#Optimizing-Program-Performance" class="headerlink" title="Optimizing Program Performance"></a>Optimizing Program Performance</h3><ul>
<li>Efficient algorithm and data structure</li>
<li>Compiler can optimize</li>
</ul>
<ol>
<li>Correctness</li>
<li>Readability </li>
<li>Performance</li>
</ol>
<ul>
<li>Trade-off between readability and performance</li>
<li>Loop Unrolling: Reduce iteration and loop operation</li>
</ul>
<h3 id="The-Memory-Hierarchy"><a href="#The-Memory-Hierarchy" class="headerlink" title="The Memory Hierarchy"></a>The Memory Hierarchy</h3><ul>
<li>Register -&gt; N-level Cache -&gt; Main Memory -&gt; Local Disk -&gt; Remote Disk</li>
<li>RAM: available when power on</li>
<li>one bit = one cell</li>
<li>SRAM(Static): Cache; bistable, 6 transistors per bit</li>
<li>DRAM(Dynamic): Main Memory; Sensitive, 1 transistor per bit</li>
<li>Memory controller with addr and data pins</li>
<li>Main Memory -&gt; Memory Modules -&gt; DRAM Chips -&gt; Supercells(row,column) -&gt; 8 cells(1 byte) </li>
<li>SDRAM: Synchronous DRAM, replace memory control with clock rise</li>
<li>DDR(Double Data Rate): Double control signal and increase buffer</li>
<li>ROM: nonvolatile when power off, limited erase time</li>
<li>EEPROM(Electrically Erasable Programmable ROM): Flash Memory, Solid State Disk</li>
<li>CPU - Bus Interface - System Bus - I/O Bridge - Memory Bus - Main Memory<br>I/O Bridge - I/O Bus(Peripheral Component Interconnect)</li>
<li>Universal Serial Bus(SSD), Host Bus Adaptor(SCSI, SATA)</li>
<li>sector + gap -&gt; track -&gt; cylinder &lt;=&gt; Logic Block</li>
<li>RPM: Revolutions Per Minute</li>
<li>Access Time = avg seek time + avg rotation latency + avg transfer time</li>
<li>Temporal Locality: reference itself; Spatial Locality: reference nearby location</li>
<li>Cache: S sets -&gt; E lines -&gt; 1 valid bit + t tag bits + B bytes block; C= BES</li>
<li>Memory Address: t bits tag + s bits set index + b bits block offset</li>
<li>Direct Mapped Cache(E=1); E-way Set Associative Cache(1&lt;E&lt;ES); Fully Associative Cache(S=1)</li>
<li>(valid == 1 &amp;&amp; tag match) ? hit : miss;</li>
<li>Miss: Fetch entire block from memory to cache line</li>
<li>Cold Miss, Conflict Miss, Capacity Miss</li>
<li>Memory Mountain: read throughput = f(size(temporal locality),stride(spatial locality))</li>
</ul>
<h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><ul>
<li>Collect and combine code and data into a single file that can be loaded into memory and executed</li>
<li>Linker enables separate complition, link at (static linker)compile time, (dynamic linker)load time, run time</li>
<li>Symbol resolution</li>
<li>Symbol: variables + functions</li>
<li>static: local symbol; nonstatic: global symbol defined by self; external: global symbol defined by others</li>
<li>strong symbol: initialized global variable and function; weak symbol: uninitialized global variable</li>
<li>strong with strong: link error; strong with weak: pick strong; weak with weak: pick any one</li>
<li>static library: lib.a(archive), only copy the object modules that are referenced</li>
<li>E: object file; U: undefined symbol; D: defined symbol</li>
<li>scan object file and static library in order and update E, U, D</li>
<li>Referenced file should after file that reference it</li>
<li>Relocation: section merge + relocate symbol reference within section</li>
<li>Load executable object file: copying the program into memory and then running</li>
<li>Shared library: dynamic link at run time, lib.so</li>
<li>dynamic link in program: handle = dlopen(lib.so); func = dlsym(handle,”func”); dlclose(handle)</li>
<li>Position Independent Code: distance between code segment and data segment is constant</li>
<li>Global Offset Table + Procedure Linkage Table</li>
</ul>
<h3 id="Exceptional-Control-Flow"><a href="#Exceptional-Control-Flow" class="headerlink" title="Exceptional Control Flow"></a>Exceptional Control Flow</h3><ul>
<li>Control Flow: Sequence of control transfer</li>
<li>Sychronous: Call return only if it finished; Asynchronous: Call return immediately and notify later if finish</li>
<li>Exception: OS and hardware(low-level), interrupt(I/O device, Processor issue to OS), trap, fault, abort</li>
<li>Event occur -&gt; exception -&gt; exception table -&gt; exception handler(kernel mode) -&gt; return/abort</li>
<li>System Call(trap, 0x80 in exception table): syscall, Application call OS<br>Fault(might recoverable)</li>
<li>Floating Exception: Divide by 0; Segmentation Fault: Access undefined address and write read-only file</li>
<li>Program: a collection of code and data</li>
<li>Process: Instance of a program in execution, illusion that has exclusive use of processor and memory</li>
<li>Process need context switching when exception occur, threads are in the same context</li>
<li>3 states of process: Running, Stopped, Terminated</li>
<li>fork(): parent -&gt; child, return child pid to parent and 0 to child, parent reap its terminated child(zombie)</li>
<li>pid waitpid(pid,status,option): waits children to terminate or stop and reap them</li>
<li>execve(filename,argv,envp): loads and runs a new program in the context of the current process</li>
<li>fork: new process, same program; execve: same process, new program</li>
<li>Signal: Application and OS(high-level), kernel notify process that event occur</li>
<li>block(can be deliver until unblock) - pending(only one for one type) - receive</li>
<li>process group: -PID</li>
<li>signal(signum,handler): install user-defined handler for handling received signal</li>
<li>Nonlocal jumps: jump to other function, setjmp(like catch) + longjmp(return setjmp, like throw)</li>
</ul>
<h3 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h3><ul>
<li>Physical Addressing(PA): 0~M-1, m bits; Virtual Addressing(VA): 0~N-1, n bits<br>Memory Management Unit(MMU) translate VA to PA</li>
<li>Cache Transfer Unit: page, block</li>
<li>Each process have its own virtual adress space and page table</li>
<li>Virtual Memory: Array of N contiguous byte-sized cells stored on disk</li>
<li>Unallocated(no space on disk), Cached(fully associative in physical memory), Uncached(on disk)</li>
<li>Page Table Base Register -&gt; Page Table(in cache or memory): each entry map VP to PP</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Virtual Page(VP)</th>
<th style="text-align:center">valid</th>
<th style="text-align:center">Physical Page(PP)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">        0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">physical address(cached), page hit</td>
</tr>
<tr>
<td style="text-align:center">        1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">disk address(uncached), page fault, swap/page in/out and execute again</td>
</tr>
<tr>
<td style="text-align:center">        2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">null(unallocated)</td>
</tr>
</tbody>
</table>
<ul>
<li>Demand Paging: the strategy of waiting until the last moment to swap in a page, when a miss occurs</li>
<li>Virtual Page Number -&gt; Page Table Entry -&gt; Physical Page Number</li>
<li>Virtual Page Offset = Physical Page Offset</li>
<li>Translation Lookaside Buffer: cache of page table(SRAM and DRAM) in MMU</li>
<li>Multi-level page tables: bits of (page amount) are separated into multiple sections</li>
<li>m*n PTEs are organized as m PTEs(level 1), n PTEs(level2) for each level 1 PTE, level 2 n PTEs doesn’t exist if corresponding level 1 PTE is null</li>
</ul>
<ol>
<li>VA -&gt;PA<br>hit: VPN -&gt; MMU(TLB) -&gt; PPN<br>miss: VPN -&gt; multi-level page table -&gt; PPN</li>
<li>Get data word<br>PA -&gt; Cache -&gt; Physical Memory</li>
</ol>
<ul>
<li>Linux Virtual Memory: vm_area_structs -&gt; different sections of process virtual memory</li>
<li>Memory Mapping: initialize virtual memory area by associating it with an object(shared, private copy-on-write, anonymous) on disk</li>
<li>mmap: create a new virtual memory area which mapped to a object; munmap: delete the area</li>
<li>brk: top of the heap; payload: actual requested size; bp: block pointer, the first word after header</li>
<li>void *sbrk(intptr_t incr); // set brk to grow or shrink the heap</li>
<li>void *malloc(size_t size); // allocate one size space, return null on error, not initialized</li>
<li>Notice Allocate Alignment!</li>
<li>void *calloc(size_t numElements, size_t sizeOfElement); // allocate initialized spaces </li>
<li>void <em>realloc(void </em>ptr, size_t newsize); // reallocate ptr with one newsize space, might in new location</li>
<li>void free(void* ptr); //explicitly free allocated block</li>
<li>Goal: maximize throughput(request number), maximize memory utilization(peak utilization)</li>
<li>internal fragmentation: allocated block &gt; request; external fragmentation: every free block &lt; request</li>
<li>boundary tags: copy header to footer, current block just check one previous word</li>
<li>implicit free list: start + 2 prologue + heap blocks(header + payload + padding + footer) + epilogue</li>
<li>placement, splitting, coalescing(false fragmentation, combine free blocks)</li>
<li>explicit free list: doubly linked free list; segregated free list: multiple free lists of different size</li>
<li>buddy system: segregated free list of sizes of power of two</li>
<li>new/delete: C++ operator, allocate/free self-defined object, do construction构造 &amp; deconstruction析构</li>
<li>Garbage Collection: implicitly free allocated block, directed graph(root nodes -&gt; heap nodes)</li>
<li>garbage: unreachable nodes which will never be used again</li>
<li>Mark&amp;Sweep: mark reachable blocks and sweep unmarked allocated blocks</li>
</ul>
<h3 id="System-Level-I-O"><a href="#System-Level-I-O" class="headerlink" title="System-Level I/O"></a>System-Level I/O</h3><ul>
<li>I/O: copy data between main memory and external device(disk drive, terminal, networks: file)</li>
<li>open/close file<ul>
<li>int open(filename,flags,mode); return file descriptor(fd); int close(fd);</li>
<li>unix shell begin with three descriptor: stdin, stdout, stderr</li>
</ul>
</li>
<li>read/write file<ul>
<li>read(fd,buf,size); write(fd,buf,size);</li>
<li>RIO(Robust I/O) for handling short counts(fewer bytes than request, EOF, text line, network delay)</li>
</ul>
</li>
<li>unbuffered for network delay; buffered for text line</li>
<li>buffer in memory can improve efficiency: interact with buffer directly rather than use system call every time to r/w some small bytes, buffer interact with file by buffersize at a time</li>
<li>change file position</li>
<li>file metadata: stat(filename,buf);</li>
<li>open file data structure<ul>
<li>descriptor table(unique for process) -&gt; open file table(file pos) -&gt; v-node table(file)(shared by process)</li>
</ul>
</li>
<li>I/O Redirection: int dup2(oldfd,newfd), copy descriptor table entry of oldfd to newfd</li>
<li>C Standard I/O, RIO(higher-level) - Unix I/O(lower-level, for network)</li>
</ul>
<h3 id="Network-Programming"><a href="#Network-Programming" class="headerlink" title="Network Programming"></a>Network Programming</h3><ul>
<li>client-server transaction: client process request server process, server process response client process</li>
<li>TCP/IP Protocol Stack: Application Layer - Transport Layer - Internet Layer - Network Access Layer</li>
<li>LAN: Bridged Ethernet(Host - Hub(copy every bit to every other port) - Bridge(selectively copy frame to dest))</li>
<li>internet: LAN - router(connect incompatible LANs); Global IP Internet: one implementation of internet</li>
<li>Reliable Transfer: no transfer error including lost, duplicate and wrong order</li>
<li>TCP(Transmission Control Protocol)/UDP(Unreliable Datagram Protocol): process to process</li>
<li>Three-way Handshake: SYN -&gt; SYN+ACK -&gt; ACK</li>
<li>IP(Internet Protocol): host to host(send datagrams, unreliable)</li>
<li>MAC Address: 48 bit; IP Address: 32 bit(ipv6: 16 Bytes), dotted-decimal notation; Network Byte Order: big-endian</li>
<li>unnamed root -&gt; first-level domain name(com) -&gt; second-level domain name(google) -&gt; third-level domain name(www)</li>
<li>Socket: end point of connection, IP address:port(16 bit); ephemeral port, well-known port</li>
<li>Socket Interface<ul>
<li>Client: open_clientfd(socket - connect) - I/O - close; Server: open_listenfd(socket - bind - listen) - accept - I/O - close</li>
<li>client blocks in connect, server blocks in accept</li>
<li>listening descriptor exist for lifetime of server(open_listenfd); connected descriptor exist during the connection(accept)</li>
</ul>
</li>
<li>World Wide Web is a service provided by Internet using HTTP(Hypertext Transfer Protocol)</li>
<li>MIME: Multipurpose Internet Mail Extensions</li>
<li>URI(Uniform Resource Identifier) = URL(locater) + URN(name)</li>
<li>HTTP Request Line: method URI version; HTTP Response Line: version status code status message</li>
<li>status code: 200(OK), 301(permanently redirect), 302(temporarily redirect), 403(Forbidden), 404(Not found)</li>
<li>CGI(Common Gateway Interface): interface with executable programs on a server that generate web pages dynamically</li>
<li>Proxy: bypass firewall, page translation, anonymizer, cache</li>
</ul>
<h3 id="Concurrent-Programming"><a href="#Concurrent-Programming" class="headerlink" title="Concurrent Programming"></a>Concurrent Programming</h3><ul>
<li>Processes<ul>
<li>parent forks a child to handle each new connection request, child closes listenfd, parent closes connfd</li>
<li>Interprocess Communication(IPC)</li>
<li>Pros: having separate virtual address space; Cons: difficult to share state information, high overhead</li>
</ul>
</li>
<li>I/O Multiplexing<ul>
<li>select function blocks until one of the descriptors in the read set is ready to read</li>
<li>state machine: (input state, input event) -&gt; output state</li>
<li>Pros: more control, share state information; Cons: complexity</li>
</ul>
</li>
<li>Threads(hybrid of Process and I/O Multiplexing)<ul>
<li>Like processes, threads are scheduled automatically by the kernel and are known to the kernel by an integer ID. Like I/O multiplexing, multiple threads run in the context of a single process, and thus share the entire contents of the process virtual address space, including its code, data, heap, shared libraries, and open files. Each thread has its own thread context(thread ID(TID), stack, stack pointer, program counter, general-purpose registers, condition codes)</li>
</ul>
</li>
<li>main thread(the first thread) </li>
<li>peer threads: thread can kill any of its peers or wait for any of its peers to terminate.</li>
<li>POSIX Thread: pthread, pthread_t tid</li>
<li>joinable thread(default): reaped and killed by other threads and memory resources are not freed until it is reaped by another thread; detached thread(prefer): cannot be reaped or killed by other threads and memory resources are freed automatically by the system when it terminates.</li>
<li>Global variables: one instance in virtual address space and can be referenced by any thread</li>
<li>Local automatic variables: each thread’s stack contains its own instances and can also be shared though</li>
<li>Local static variables: one instance in virtual address space and can be referenced by any thread</li>
<li>Thread safe: manipulate shared data structures by multiple threads and guarantee safe execution and correct result </li>
<li>Thread synchronization: coordinate threads to access critical section</li>
<li>Semaphore: solution to synchronization, a nonnegative global variable s</li>
<li>P(s): decrement s if s is nonzero, block if s is zero until V(s); V(s): increment s, restart one P(s) if s becomes nonzero</li>
<li>P and V cannot be interrupted: atomic operation</li>
<li>Mutual Exclusion: initialize s with 1; P(s); Do(); V(s); Only can execute Do() with THE ONE s(mutex), like talking pillow</li>
<li>Producer-Consumer Problem: Producer: P(slot)-P(mutex)-insert-V(mutex)-V(item); Consumer: P(item)-P(mutex)-remove-V(mutex)-V(slot)</li>
<li>Readers-Writers Problem: reader-favored(reader can read although writer is waiting); writer-favored(writer write as soon as possible after the previous readers finish)</li>
<li>Reader: P(mutex); readcnt++; if(readcnt == 1) {P(w);} V(mutex); Read(); P(mutex); readcnt–; if(readcnt == 0) {V(w);} V(mutex); Writer: P(w); Write(); V(w);</li>
<li>Parallel programs are often written so that each core runs exactly one thread(cat /proc/cpuinfo)</li>
<li>Reentrant function(subset of thread-safe function): do not reference any shared data</li>
<li>Deadlock: each thread is waiting for the other to do V that will never occur, because of wrong order of P and V</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一下我在上CMU的18-600: Foundations of Computer Systems (15-213: Introduction to Computer Systems在ECE系的改编课程)时对教材”Computer Systems: A Programme
    
    </summary>
    
      <category term="Tech" scheme="http://cheesehigh.com/categories/Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>World Peace</title>
    <link href="http://cheesehigh.com/2016/07/07/peace/"/>
    <id>http://cheesehigh.com/2016/07/07/peace/</id>
    <published>2016-07-07T15:22:39.000Z</published>
    <updated>2016-07-13T14:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续读了2个月，毕业了，两本总共800多页的《全球通史》也读完了，还外加一些相关的纪录片和电影。</p>
<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>寒假看完了火影究极风暴4的游戏视频，重新梳理了一遍火影的世界观。大概是这样的，公主大筒木辉夜吃了查克拉树上的果子暴走变成了十尾，她的两个儿子羽衣和羽村联合封印了辉夜，之后羽衣成了六道仙人，将十尾查克拉分给了九只尾兽，他的两个儿子阿修罗和因陀罗从此拉开了千手和宇智波世世代代的羁绊与恩怨。故事的主要纷争就在于两种意识形态的对立，即怎样才能达到「和平」。佩恩、带土、斑等反派们认为只有消除现存的一切，建立一个虚幻的梦境世界，那里没有死亡，只有虚假的幸福。鸣人则认为只有相信他能够消除仇恨，冤冤相报的命运才能终结。当然最后是主角们开挂打赢了战斗，但是只要有续集，就会有斗争和仇恨，鸣人的理想只能在嘴遁上停留。</p>
<p>那么我们生活的这个世界呢？</p>
<h3 id="文明与战争"><a href="#文明与战争" class="headerlink" title="文明与战争"></a>文明与战争</h3><p>人类的文明史就是一部战争史。资源是有限的，斗争，是地球，甚至是整个宇宙的生存法则。文明的进步在给人类带来便利，对抗疾病、饥饿的同时，斗争也在不断扩大。</p>
<p>旧石器时代。人类还在用火和野兽斗争。</p>
<p>新石器时代。人类逐渐站上食物链顶端，但还零零散散地散步在世界各个角落，基本能够做到自给自足。</p>
<p>古代文明。四个文明古国开始产生，黄河流域的中国，印度河流域的印度，两河流域的巴比伦，尼罗河流域的埃及。文明的周围是野蛮。游牧民族们无时无刻不在觊觎着富庶的大国，千年不断的入侵和掠夺开始了。</p>
<p>古典文明。希腊开启了人类历史上的第一个黄金时代，但还是经历了和波斯的战争，雅典和斯巴达的内战。伟大的罗马帝国被一分为二，天主和东正为了上帝争论不休。遥远的东方相信「分久必合，合久必分」，每隔一段时间就来一次朝代更替。</p>
<p>中世纪文明。我们的穆罕穆德登场了，中东都变成了绿色，基督徒和穆斯林千年血战拉开序幕。电影《Kindom of Heaven》中的耶路撒冷将军Tiberias死前终于明白了，「First, I thought we were fighting for God. Then I realized we were fighting for wealth and land」。若干年以后，君士坦丁堡被自己人洗劫了。</p>
<p>近代文明。杀戮原住民并殖民是这几百年的主题。我们都熟悉的，为了殖民地利益而爆发的一战，为了「生存空间」而爆发的二战。</p>
<h3 id="和平"><a href="#和平" class="headerlink" title="和平"></a>和平</h3><p>Thomas Paine在《人的权利》中写道：在厌倦了战争和人类的屠杀后，他们坐下来休息，并称之为和平。</p>
<p>如果可以，休息地久一点吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续读了2个月，毕业了，两本总共800多页的《全球通史》也读完了，还外加一些相关的纪录片和电影。&lt;/p&gt;
&lt;h3 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h3&gt;&lt;p&gt;寒假看完了火影究极风暴4
    
    </summary>
    
      <category term="History" scheme="http://cheesehigh.com/categories/History/"/>
    
    
  </entry>
  
  <entry>
    <title>I Love Five</title>
    <link href="http://cheesehigh.com/2016/06/02/hello/"/>
    <id>http://cheesehigh.com/2016/06/02/hello/</id>
    <published>2016-06-02T15:42:10.000Z</published>
    <updated>2016-06-30T13:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I Love Five</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
    
    </summary>
    
      <category term="Five" scheme="http://cheesehigh.com/categories/Five/"/>
    
    
  </entry>
  
</feed>
